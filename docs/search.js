window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "gsvpd", "modulename": "gsvpd", "kind": "module", "doc": "<p>gsvpd - Google Street View Panorama Downloader</p>\n\n<p>This module provides tools to download, process, and stitch Google Street View panoramas.</p>\n\n<p>Key features:</p>\n\n<ul>\n<li>Concurrently fetch panorama tiles using asyncio + aiohttp.</li>\n<li>Detect and skip black or missing tiles.</li>\n<li>Stitch tiles into complete panorama images.</li>\n<li>Save images in structured directories with human-readable file sizes.</li>\n<li>Supports multiple zoom levels (0\u20135).</li>\n</ul>\n\n<p>Example usage::</p>\n\n<pre><code>import asyncio\nimport aiohttp\nfrom gsvpd import fetch_panos\nfrom gsvpd import timer\nfrom rich import print\n\nasync def main():\n    dataset = [\"list of pano ids\"]\n    sem_pano = asyncio.Semaphore(100)\n    sem_tile = asyncio.Semaphore(100)\n    connector = aiohttp.TCPConnector(limit=100, limit_per_host=100)\n    zoom_level = 2\n    workers = 5\n    return await fetch_panos(sem_pano, sem_tile, connector, workers, zoom_level, dataset)\n\nwith timer() as t:\n    total_panos, successful_panos, output_dir = asyncio.run(main())\n    print(f\"Processed {successful_panos}/{total_panos} panos in {t.time_elapsed}\")\n    print(f\"Saved at {output_dir}\")\n</code></pre>\n"}, {"fullname": "gsvpd.constants", "modulename": "gsvpd.constants", "kind": "module", "doc": "<p>Constants for panorama tile sizes and counts.</p>\n\n<p>ZOOM_SIZES: Post-2016 panorama sizes by zoom level.\nOLD_ZOOM_SIZES: Pre-2016 panorama sizes.\nTILES_AXIS_COUNT: Number of tiles along X and Y axes per zoom level.\nTILE_COUNT_TO_SIZE: Mapping of tile counts to panorama dimensions.\nTILE_SIZE: Tile dimension in pixels (square tiles).</p>\n"}, {"fullname": "gsvpd.constants.ZOOM_SIZES", "modulename": "gsvpd.constants", "qualname": "ZOOM_SIZES", "kind": "variable", "doc": "<p></p>\n", "default_value": "{0: (512, 256), 1: (1024, 512), 2: (2048, 1024)}"}, {"fullname": "gsvpd.constants.OLD_ZOOM_SIZES", "modulename": "gsvpd.constants", "qualname": "OLD_ZOOM_SIZES", "kind": "variable", "doc": "<p></p>\n", "default_value": "{0: (416, 208), 1: (832, 416), 2: (1664, 832)}"}, {"fullname": "gsvpd.constants.TILES_AXIS_COUNT", "modulename": "gsvpd.constants", "qualname": "TILES_AXIS_COUNT", "kind": "variable", "doc": "<p></p>\n", "default_value": "{0: (0, 0), 1: (1, 0), 2: (3, 1), 3: (7, 3), 4: (15, 7), 5: (31, 15)}"}, {"fullname": "gsvpd.constants.TILE_COUNT_TO_SIZE", "modulename": "gsvpd.constants", "qualname": "TILE_COUNT_TO_SIZE", "kind": "variable", "doc": "<p></p>\n", "default_value": "{(8, 4): (4096, 2048), (7, 4): (3328, 1664), (16, 8): (8192, 4096), (13, 7): (6656, 3328), (32, 16): (16384, 8192), (26, 13): (13312, 6656)}"}, {"fullname": "gsvpd.constants.TILE_SIZE", "modulename": "gsvpd.constants", "qualname": "TILE_SIZE", "kind": "variable", "doc": "<p></p>\n", "default_value": "512"}, {"fullname": "gsvpd.core", "modulename": "gsvpd.core", "kind": "module", "doc": "<p>Core module for downloading, processing, and stitching Google Street View panoramas.</p>\n\n<p>This module provides asynchronous functions to:</p>\n\n<ul>\n<li>Fetch individual panorama tiles from Google Street View with retry logic (<code>fetch_tile</code>).</li>\n<li>Determine panorama dimensions based on zoom level and tile content (<code>determine_dimensions</code>).</li>\n<li>Stitch multiple tiles into a single panorama image (<code>stitch_tiles</code>).</li>\n<li>Process a single panorama by fetching tiles, determining dimensions, stitching, and saving (<code>process_panoid</code>).</li>\n<li>Download and process multiple panoramas concurrently (<code>fetch_panos</code>).</li>\n</ul>\n\n<p>The module supports different zoom levels (0\u20135) and handles old (pre-2016) and new panorama formats.\nIt uses asyncio for concurrent network requests and a process pool executor for CPU-bound tasks like image analysis.</p>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>aiohttp for asynchronous HTTP requests</li>\n<li>PIL/Pillow for image processing</li>\n<li>rich for colored logging</li>\n</ul>\n"}, {"fullname": "gsvpd.core.fetch_tile", "modulename": "gsvpd.core", "qualname": "fetch_tile", "kind": "function", "doc": "<p>Fetch a single panorama tile from Google Street View with retry support.</p>\n\n<p>Args:\n    session (aiohttp.ClientSession): The active HTTP session.\n    panoid (str): The panorama ID to fetch tiles from.\n    x (int): Tile X index.\n    y (int): Tile Y index.\n    zoom_level (int): Zoom level (0\u20135).\n    retries (int): Number of retry attempts on failure (default: 3).\n    backoff (float): Initial backoff delay in seconds between retries (default: 1.0).</p>\n\n<p>Returns:\n    tuple[int, int, PIL.Image.Image] | None: \n        A tuple containing (x, y, tile image) if successful, otherwise None.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">session</span><span class=\"p\">:</span> <span class=\"n\">aiohttp</span><span class=\"o\">.</span><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">ClientSession</span>,</span><span class=\"param\">\t<span class=\"n\">panoid</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">retries</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">backoff</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.core.determine_dimensions", "modulename": "gsvpd.core", "qualname": "determine_dimensions", "kind": "function", "doc": "<p>Determine the width and height of a panorama image based on zoom level \nand tile analysis.</p>\n\n<p>For zoom level 0:\n    - Uses <code>black_percentage</code> to check if it's an old panorama.\nFor zoom levels 1\u20132:\n    - Uses <code>has_black_bottom</code> to detect old panorama bottom margin.\nFor zoom levels 3+:\n    - Uses <code>TILE_COUNT_TO_SIZE</code> lookup.</p>\n\n<p>Args:\n    executor (ProcessPoolExecutor | None): Executor for CPU-bound tasks.\n    tiles (list): List of tiles in the format [(x, y, Image), ...].\n    zoom_level (int): Zoom level (0\u20135).\n    x_tiles_count (int): Number of horizontal tiles fetched.\n    y_tiles_count (int): Number of vertical tiles fetched.</p>\n\n<p>Returns:\n    Tuple[int, int]: Width and height of the panorama in pixels.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">executor</span>,</span><span class=\"param\">\t<span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">x_tiles_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_tiles_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.core.stitch_tiles", "modulename": "gsvpd.core", "qualname": "stitch_tiles", "kind": "function", "doc": "<p>Combine individual panorama tiles into a single stitched image.</p>\n\n<p>Args:\n    tiles (list): List of tiles as tuples (x, y, Image).\n    width (int): Total width of the stitched image.\n    height (int): Total height of the stitched image.</p>\n\n<p>Returns:\n    PIL.Image.Image: The final stitched panorama image.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tiles</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">PIL</span><span class=\"o\">.</span><span class=\"n\">Image</span><span class=\"o\">.</span><span class=\"n\">Image</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.core.process_panoid", "modulename": "gsvpd.core", "qualname": "process_panoid", "kind": "function", "doc": "<p>Download, reconstruct, and save a single panorama.</p>\n\n<p>Steps:\n    1. Fetch all tiles for the given panoid and zoom level.\n    2. Filter out black or missing tiles.\n    3. Determine panorama dimensions using zoom level and tile content.\n    4. Stitch tiles into a single panorama image.\n    5. Save the resulting image to disk.\n    6. Return metadata about the panorama.</p>\n\n<p>Args:\n    session (aiohttp.ClientSession): Active HTTP session.\n    panoid (str): Panorama ID to fetch.\n    sem_pano (asyncio.Semaphore): Semaphore to limit concurrent panorama downloads.\n    executor (ProcessPoolExecutor): Executor for CPU-bound tasks.\n    zoom_level (int): Zoom level (0\u20135).\n    output_dir (str): Directory to save the panorama image.</p>\n\n<p>Returns:\n    dict | None: Metadata dictionary containing:\n        - \"panoid\" (str): Panorama ID.\n        - \"zoom\" (int): Zoom level used.\n        - \"size\" (tuple[int, int]): Image width and height in pixels.\n        - \"tiles\" (tuple[int, int]): Count of tiles (x_tiles, y_tiles).\n        - \"file_size\" (int): Size of saved image in bytes.\n    Returns None if the panorama could not be fetched or processed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">session</span><span class=\"p\">:</span> <span class=\"n\">aiohttp</span><span class=\"o\">.</span><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">ClientSession</span>,</span><span class=\"param\">\t<span class=\"n\">panoid</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">sem_pano</span><span class=\"p\">:</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">locks</span><span class=\"o\">.</span><span class=\"n\">Semaphore</span>,</span><span class=\"param\">\t<span class=\"n\">executor</span><span class=\"p\">:</span> <span class=\"n\">concurrent</span><span class=\"o\">.</span><span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"n\">process</span><span class=\"o\">.</span><span class=\"n\">ProcessPoolExecutor</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.core.fetch_panos", "modulename": "gsvpd.core", "qualname": "fetch_panos", "kind": "function", "doc": "<p>Download and process multiple panoramas concurrently.</p>\n\n<p>Args:\n    sem_pano (asyncio.Semaphore): Semaphore to control concurrent pano downloads.\n    connector (aiohttp.TCPConnector): Connector with concurrency limits for aiohttp.\n    max_workers (int): Max number of workers for the process pool (used for image checks).\n    zoom_level (int): Zoom level (0\u20135).\n    panoids (list[str]): List of panorama IDs to fetch.</p>\n\n<p>Workflow:\n    - Creates an aiohttp session.\n    - Uses a process pool executor for CPU-bound tasks.\n    - Runs <code>process_panoid()</code> for each panoid concurrently.</p>\n\n<p>Returns:\n    tuple[int, int, str]: A tuple containing:\n        - total_panos (int): Number of panorama IDs processed.\n        - successful_panos (int): Number of panoramas successfully downloaded.\n        - output_dir (str): Output directory where the panoramas are saved.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sem_pano</span><span class=\"p\">:</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">locks</span><span class=\"o\">.</span><span class=\"n\">Semaphore</span>,</span><span class=\"param\">\t<span class=\"n\">connector</span><span class=\"p\">:</span> <span class=\"n\">aiohttp</span><span class=\"o\">.</span><span class=\"n\">connector</span><span class=\"o\">.</span><span class=\"n\">TCPConnector</span>,</span><span class=\"param\">\t<span class=\"n\">max_workers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">panoids</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.my_utils", "modulename": "gsvpd.my_utils", "kind": "module", "doc": "<p>Utility module for Google Street View panorama processing.</p>\n\n<p>This module provides helper functions and classes for:</p>\n\n<ul>\n<li>Timing code execution (<code>timer</code> context manager).</li>\n<li>Analyzing panorama tiles for black pixels (<code>has_black_bottom</code>, <code>black_percentage</code>).</li>\n<li>Loading datasets (<code>open_dataset</code>).</li>\n<li>Parsing command-line arguments for the panorama downloader (<code>parse_args</code>).</li>\n<li>Saving panorama images and formatting file sizes (<code>save_img</code>, <code>format_size</code>).</li>\n</ul>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy for image pixel analysis</li>\n<li>PIL/Pillow for image handling</li>\n<li>rich for colored terminal output</li>\n<li>argparse for CLI argument parsing</li>\n<li>json and os for dataset management and file handling</li>\n</ul>\n"}, {"fullname": "gsvpd.my_utils.timer", "modulename": "gsvpd.my_utils", "qualname": "timer", "kind": "class", "doc": "<p>Context manager to measure and print elapsed execution time.</p>\n\n<p>Usage:\n    with timer():</p>\n\n<h2 id=\"your-code-here\">        # your code here</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">with</span> <span class=\"n\">timer</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">t</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># some code to measure</span>\n<span class=\"gp\">... </span>    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">time_elapsed</span><span class=\"p\">)</span>\n<span class=\"go\">&#39;0h 0m 2.00s&#39;</span>\n</code></pre>\n</div>\n"}, {"fullname": "gsvpd.my_utils.has_black_bottom", "modulename": "gsvpd.my_utils", "qualname": "has_black_bottom", "kind": "function", "doc": "<p>Check if the bottom rows of a tile image are completely black.</p>\n\n<p>Args:\n    tile (PIL.Image.Image): The image tile to check.\n    black_threshold (int, optional): Max RGB value considered 'black'. Defaults to 10.\n    check_rows (int, optional): Number of bottom rows to inspect. Defaults to 5.</p>\n\n<p>Returns:\n    bool: True if all bottom rows are black, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tile</span>, </span><span class=\"param\"><span class=\"n\">black_threshold</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">check_rows</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.my_utils.black_percentage", "modulename": "gsvpd.my_utils", "qualname": "black_percentage", "kind": "function", "doc": "<p>Calculate the percentage of black pixels in a tile.</p>\n\n<p>Args:\n    tile (PIL.Image.Image): Tile image to analyze.\n    threshold (int, optional): Max RGB value to consider a pixel 'black'. Defaults to 10.</p>\n\n<p>Returns:\n    float: Percentage of black pixels (0\u2013100).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tile</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.my_utils.open_dataset", "modulename": "gsvpd.my_utils", "qualname": "open_dataset", "kind": "function", "doc": "<p>Load dataset JSON file.</p>\n\n<p>Args:\n    dataset_location (str): Path to dataset JSON file.</p>\n\n<p>Returns:\n    list[str]: Parsed JSON data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset_location</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.my_utils.parse_args", "modulename": "gsvpd.my_utils", "qualname": "parse_args", "kind": "function", "doc": "<p>Parse command-line arguments for the panorama downloader.</p>\n\n<p>Arguments:\n    --zoom (int, required): Zoom level (0\u20135).\n    --dataset (str, optional): Path to dataset JSON file. Default: ./dataset.json\n    --max-pano (int, optional): Max concurrent pano downloads. Default: 50\n    --max-tile (int, optional): Max concurrent tile downloads per pano. Default: 50\n    --workers (int, optional): Max process pool workers. Default: 20\n    --limit (int, optional): Limit panoids for testing. Default: None</p>\n\n<p>Returns:\n    argparse.Namespace: Parsed arguments object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.my_utils.format_size", "modulename": "gsvpd.my_utils", "qualname": "format_size", "kind": "function", "doc": "<p>Convert a file size in bytes into a human-readable string.</p>\n\n<p>Args:\n    num_bytes (int): File size in bytes.</p>\n\n<p>Returns:\n    str: Formatted size (e.g., '512.00 KB', '384.00 MB').</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num_bytes</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.my_utils.save_img", "modulename": "gsvpd.my_utils", "qualname": "save_img", "kind": "function", "doc": "<p>Save a PIL image to disk in a structured directory layout and return its file size.</p>\n\n<p>The function creates a subdirectory based on the zoom level (e.g., \"panos_z1\"),\nsaves the given image as a JPEG file named with the provided panorama ID, and\ncalculates the saved file's size in a human-readable format.</p>\n\n<p>Args:\n    full_img (Image): A PIL Image object to be saved.\n    output_dir (str): Base directory where the image should be stored.\n    panoid (str): Unique panorama identifier used as the output filename.\n    zoom_level (int): Zoom level used to organize the output directory.</p>\n\n<p>Returns:\n    str: File size of the saved image in a human-readable format \n         (e.g., \"512.00 KB\", \"1.23 MB\").</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">full_img</span><span class=\"p\">:</span> <span class=\"n\">PIL</span><span class=\"o\">.</span><span class=\"n\">Image</span><span class=\"o\">.</span><span class=\"n\">Image</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">panoid</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">zoom_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.tests", "modulename": "gsvpd.tests", "kind": "module", "doc": "<p>Test suite for the <code>gsvpd</code> module.</p>\n\n<p>This package contains unit and integration tests for <code>gsvpd</code> functionality, including:</p>\n\n<ul>\n<li><code>core</code> module tests: fetching tiles, processing panoramas, handling errors, and stitching images.</li>\n<li>Utilities for generating dummy images and mocking async HTTP calls.</li>\n<li>Async tests using <code>pytest.mark.asyncio</code> and <code>unittest.mock</code> for patching.</li>\n</ul>\n\n<p>Usage:</p>\n\n<pre><code># Run all tests in the package\npytest gsvpd/tests\n\n# Run a specific test file\npytest gsvpd/tests/test_core.py\n</code></pre>\n"}, {"fullname": "gsvpd.tests.test_core", "modulename": "gsvpd.tests.test_core", "kind": "module", "doc": "<p>Unit and integration tests for the <code>core</code> module of the Google Street View\nPanorama Downloader.</p>\n\n<p>This test suite covers:</p>\n\n<ul>\n<li><code>fetch_tile</code>: verifies successful fetches, handling of black tiles, and\nnetwork failures.</li>\n<li><code>process_panoid</code>: tests panorama processing with mocked tiles, including\ndifferent zoom levels, empty results, and file saving.</li>\n<li><code>fetch_panos</code>: ensures batch panorama downloads handle partial or complete\nfailures, empty datasets, and correct file outputs.</li>\n<li><code>determine_dimensions</code>: validates fallback behavior and tile-based dimension\ncalculation.</li>\n</ul>\n\n<p>Utilities:</p>\n\n<ul>\n<li><code>dummy_image</code> and <code>dummy_image_bytes</code> provide in-memory images for testing.</li>\n</ul>\n\n<p>The tests use:</p>\n\n<ul>\n<li><code>pytest</code> with <code>pytest.mark.asyncio</code> for async test support.</li>\n<li><code>unittest.mock</code> and <code>monkeypatch</code> for patching async HTTP calls and\ninternal functions.</li>\n<li><code>tmp_path</code> fixtures to test file writing without polluting the filesystem.</li>\n</ul>\n\n<p>Usage:\n    pytest gsvpd/tests/test_core.py</p>\n"}, {"fullname": "gsvpd.tests.test_core.dummy_image_bytes", "modulename": "gsvpd.tests.test_core", "qualname": "dummy_image_bytes", "kind": "function", "doc": "<p>Generate dummy image bytes for testing.</p>\n\n<p>Args:\n    size (tuple[int, int]): Width and height of the image.\n    color (tuple[int, int, int]): RGB color of the image.</p>\n\n<p>Returns:\n    bytes: Image data in JPEG format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.tests.test_core.dummy_image", "modulename": "gsvpd.tests.test_core", "qualname": "dummy_image", "kind": "function", "doc": "<p>Generate a PIL Image object for testing.</p>\n\n<p>Args:\n    size (tuple[int, int]): Width and height of the image.\n    color (tuple[int, int, int]): RGB color of the image.</p>\n\n<p>Returns:\n    PIL.Image.Image: Dummy image object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_tile_success_mocked", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_tile_success_mocked", "kind": "function", "doc": "<p>Test fetch_tile with a successful mocked HTTP response.</p>\n\n<p>Ensures that fetch_tile returns a tuple (x, y, Image) for a valid tile.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monkeypatch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_tile_black_tile_mocked", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_tile_black_tile_mocked", "kind": "function", "doc": "<p>Test fetch_tile handling of a black tile.</p>\n\n<p>If the tile size matches the black tile byte size, fetch_tile should return None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monkeypatch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_tile_failure", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_tile_failure", "kind": "function", "doc": "<p>Test fetch_tile behavior when network requests fail.</p>\n\n<p>Ensures the function returns None after retries.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_process_panoid_success", "modulename": "gsvpd.tests.test_core", "qualname": "test_process_panoid_success", "kind": "function", "doc": "<p>Test process_panoid with mocked tiles to simulate successful panorama download.</p>\n\n<p>Checks that the returned metadata is correct and the image file exists.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monkeypatch</span>, </span><span class=\"param\"><span class=\"n\">tmp_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_different_zoom_levels", "modulename": "gsvpd.tests.test_core", "qualname": "test_different_zoom_levels", "kind": "function", "doc": "<p>Test process_panoid across different zoom levels with mocked tiles.</p>\n\n<p>Ensures tiles and image metadata are correctly calculated for each zoom level.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zoom_level</span>, </span><span class=\"param\"><span class=\"n\">tmp_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_process_panoid_no_tiles", "modulename": "gsvpd.tests.test_core", "qualname": "test_process_panoid_no_tiles", "kind": "function", "doc": "<p>Test process_panoid behavior when no tiles are returned.</p>\n\n<p>Ensures the function returns None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monkeypatch</span>, </span><span class=\"param\"><span class=\"n\">tmp_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_panos_with_failures", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_panos_with_failures", "kind": "function", "doc": "<p>Test fetch_panos with some panoramas failing.</p>\n\n<p>Ensures only successful panoramas are counted and saved.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tmp_path</span>, </span><span class=\"param\"><span class=\"n\">monkeypatch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_panos_empty_dataset", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_panos_empty_dataset", "kind": "function", "doc": "<p>Test fetch_panos when given an empty list of panoids.</p>\n\n<p>Should return zero total and successful panoramas.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tmp_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_fetch_panos_all_failures", "modulename": "gsvpd.tests.test_core", "qualname": "test_fetch_panos_all_failures", "kind": "function", "doc": "<p>Test fetch_panos when all panorama fetches fail.</p>\n\n<p>Ensures total count equals input panoids but successful count is zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tmp_path</span>, </span><span class=\"param\"><span class=\"n\">monkeypatch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}, {"fullname": "gsvpd.tests.test_core.test_determine_dimensions_fallback", "modulename": "gsvpd.tests.test_core", "qualname": "test_determine_dimensions_fallback", "kind": "function", "doc": "<p>Test the <code>determine_dimensions</code> function fallback behavior for zoom levels\ngreater than 2 (where TILE_COUNT_TO_SIZE lookup is used).</p>\n\n<ul>\n<li>Creates a dummy PIL image wrapped in a single-tile list.</li>\n<li>Calls <code>determine_dimensions</code> with zoom level 3 and arbitrary tile counts.</li>\n<li>Verifies that the returned dimensions match the expected value from \nTILE_COUNT_TO_SIZE.</li>\n</ul>\n\n<p>This ensures that <code>determine_dimensions</code> correctly falls back to the\ntile-count mapping for higher zoom levels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "async def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();